#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt

# Use matplotlib to generate the graphic for the 
# http://www.physics-geek.us discussion on transverse waves

# Using double sided gaussian to show path of the plucked of the string
x = np.linspace(-1, 15, 512)

f = np.piecewise(x, 
[x < 8, x >=8],
[lambda x: (25/(np.sqrt(2*np.pi)))*(np.exp(-((x-8)**2/40)))-1.5,
lambda x: (18/(np.sqrt(2*np.pi)))*(np.exp(-((x-8)**2/5)))+1.3])

# The tension vector in the positive direction. By components.

XP = 5.3
YP = 6.8
UP = 1.6
VP = 1.8

# The tension vector in the negative direction.

XN = 1.1
YN = 1.5
UN = -1.6
VN = -1.8

# Define lines measuring eta1 and eta2

xeta1 = [5.3, 10.0]
yeta1 = [6.8, 6.8]

xeta2 = [0.0, 1.1]
yeta2 = [1.5, 1.5]

# Define lines measuring x1 and x2

x1 = [5.3, 5.3]
y1 = [6.8, 0.0]

x2 = [1.1, 1.1]
y2 = [1.5, 0.0]

# set up the plotting space

fig = plt.figure()
ax = fig.add_subplot(111)

# Plot the path of the string
ax.plot(x, f)

# Plot the tension vectors

ax.arrow(XP, YP, UP, VP, fc="k", ec="k", head_width=0.2, head_length= 0.3 )
ax.arrow(XN, YN, UN, VN, fc="k", ec="k", head_width=0.2, head_length= 0.3 )

# Plot lines for eta and x

ax.plot(xeta1, yeta1, 'k--')
ax.plot(xeta2, yeta2, 'k--')
ax.plot(x1, y1, 'k--')
ax.plot(x2, y2, 'k--')

# Plot the angles of deflection


# Labels for graph

plt.text(1.2, 0.6, r'$\eta_1$', fontsize=20)
plt.text(5.8, 4.6, r'$\eta_2$', fontsize=20)
plt.text(-1.0, 9.0, r'$\eta$', fontsize=20)
plt.text(15.0, -1.0, r'$x$', fontsize=20)


# The code for removing the axis and replacing with arrows came from
# https://github.com/Felix11H/axis_arrowheads
# Used with permission from Felix

xmin, xmax = ax.get_xlim() 
ymin, ymax = ax.get_ylim()

ymin = ymin
ymax = ymax

# removing the default axis on all sides:
for side in ['bottom','right','top','left']:
    ax.spines[side].set_visible(False)
 
# removing the axis ticks
plt.xticks([]) # labels 
plt.yticks([])
ax.xaxis.set_ticks_position('none') # tick markers
ax.yaxis.set_ticks_position('none')
 
# wider figure for demonstration
fig.set_size_inches(6,4)
 
# get width and height of axes object to compute 
# matching arrowhead length and width
dps = fig.dpi_scale_trans.inverted()
bbox = ax.get_window_extent().transformed(dps)
width, height = bbox.width, bbox.height
 
# manual arrowhead width and length
hw = 1./20.*(ymax-ymin) 
hl = 1./20.*(xmax-xmin)
lw = 1. # axis line width
ohg = 0.3 # arrow overhang
 
# compute matching arrowhead length and width
yhw = hw/(ymax-ymin)*(xmax-xmin)* height/width 
yhl = hl/(xmax-xmin)*(ymax-ymin)* width/height
 
# draw x and y axis
ax.arrow(xmin, 0, xmax-xmin, 0., fc='k', ec='k', lw = lw, 
         head_width=hw, head_length=hl, overhang = ohg, 
         length_includes_head= True, clip_on = False) 
 
ax.arrow(0, ymin, 0., ymax-ymin, fc='k', ec='k', lw = lw, 
         head_width=yhw, head_length=yhl, overhang = ohg, 
         length_includes_head= True, clip_on = False) 
plt.show()
